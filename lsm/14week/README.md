
# 1. 징검다리
문제 설명<br>
출발지점부터 distance만큼 떨어진 곳에 도착지점이 있습니다. 그리고 그사이에는 바위들이 놓여있습니다. 바위 중 몇 개를 제거하려고 합니다. <br>
예를 들어, 도착지점이 25만큼 떨어져 있고, 바위가 [2, 14, 11, 21, 17] 지점에 놓여있을 때 바위 2개를 제거하면 출발지점, 도착지점, 바위 간의 거리가 아래와 같습니다. <br>
<br>
제거한 바위의 위치	각 바위 사이의 거리	거리의 최솟값<br>
[21, 17]	[2, 9, 3, 11]	2<br>
[2, 21]	[11, 3, 3, 8]	3<br>
[2, 11]	[14, 3, 4, 4]	3<br>
[11, 21]	[2, 12, 3, 8]	2<br>
[2, 14]	[11, 6, 4, 4]	4<br>
위에서 구한 거리의 최솟값 중에 가장 큰 값은 4입니다.<br>

출발지점부터 도착지점까지의 거리 distance, 바위들이 있는 위치를 담은 배열 rocks, 제거할 바위의 수 n이 매개변수로 주어질 때, 바위를 n개 제거한 뒤 각 지점 사이의 거리의 최솟값 중에 가장 큰 값을 return 하도록 solution 함수를 작성해주세요.<br>
<br>
제한사항<br>
도착지점까지의 거리 distance는 1 이상 1,000,000,000 이하입니다.<br>
바위는 1개 이상 50,000개 이하가 있습니다.<br>
n 은 1 이상 바위의 개수 이하입니다.<br>
입출력 예<br>
distance	rocks	n	return<br>
25	[2, 14, 11, 21, 17]	2	4<br>
입출력 예 설명<br>
문제에 나온 예와 같습니다.<br>

# 2. 최소직사각형<br>
문제 설명<br>
명함 지갑을 만드는 회사에서 지갑의 크기를 정하려고 합니다. 다양한 모양과 크기의 명함들을 모두 수납할 수 있으면서, 작아서 들고 다니기 편한 지갑을 만들어야 합니다. 이러한 요건을 만족하는 지갑을 만들기 위해 디자인팀은 모든 명함의 가로 길이와 세로 길이를 조사했습니다.<br>
<br>
아래 표는 4가지 명함의 가로 길이와 세로 길이를 나타냅니다.<br>
<br>
명함 번호	가로 길이	세로 길이<br>
1	60	50<br>
2	30	70<br>
3	60	30<br>
4	80	40<br>
가장 긴 가로 길이와 세로 길이가 각각 80, 70이기 때문에 80(가로) x 70(세로) 크기의 지갑을 만들면 모든 명함들을 수납할 수 있습니다. 하지만 2번 명함을 가로로 눕혀 수납한다면 80(가로) x 50(세로) 크기의 지갑으로 모든 명함들을 수납할 수 있습니다. 이때의 지갑 크기는 4000(=80 x 50)입니다.<br>
<br>
모든 명함의 가로 길이와 세로 길이를 나타내는 2차원 배열 sizes가 매개변수로 주어집니다. 모든 명함을 수납할 수 있는 가장 작은 지갑을 만들 때, 지갑의 크기를 return 하도록 solution 함수를 완성해주세요.<br>
<br>
제한사<
sizes의 길이는 1 이상 10,000 이하입니다.<br>
sizes의 원소는 [w, h] 형식입니다.<br>
w는 명함의 가로 길이를 나타냅니다.<br>
h는 명함의 세로 길이를 나타냅니다.<br>
w와 h는 1 이상 1,000 이하인 자연수입니다.<br>
입출력 예<br>
sizes	result<br>
[[60, 50], [30, 70], [60, 30], [80, 40]]	4000<br>
[[10, 7], [12, 3], [8, 15], [14, 7], [5, 15]]	120<br>
[[14, 4], [19, 6], [6, 16], [18, 7], [7, 11]]	1<br>
입출력 예 설명<br>
입출력 예 #1<br>
문제 예시와 같습니다.<br>
<br>
입출력 예 #2<br>
명함들을 적절히 회전시켜 겹쳤을 때, 3번째 명함(가로: 8, 세로: 15)이 다른 모든 명함보다 크기가 큽니다. 따라서 지갑의 크기는 3번째 명함의 크기와 같으며, 120(=8 x 15)을 return 합니다.<br>
<br>
입출력 예 #3<br>
명함들을 적절히 회전시켜 겹쳤을 때, 모든 명함을 포함하는 가장 작은 지갑의 크기는 133(=19 x 7)입니다.
